<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1e3c72">
  <title>Solitaire</title>
  <style>
    * {
      margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: fixed;
      -webkit-text-size-adjust: 100%;
      overscroll-behavior: none;
      background: url('https://cdn.abacus.ai/images/61532888-b4fb-486e-a6e6-6048b597d710.png') center center / cover no-repeat fixed;
      /* Moved background here for better mobile visibility */
      background-attachment: fixed;
      background-size: cover;
      background-position: center center;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      user-select: none;
      -webkit-user-select: none;
      padding-bottom: env(safe-area-inset-bottom, 0);
      background: transparent; /* transparent to show html background */
    }

    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 8px;
      padding-top: 68px; /* moved up 60px from 128px */
      overflow: hidden;
      height: 100dvh;
      height: calc(var(--vh, 1vh) * 100);
      touch-action: none;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(2px);
    }

    #controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      margin-bottom: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 100;
      position: relative;
      margin-bottom: calc(8px + env(safe-area-inset-bottom, 0));
    }

    #score-display {
      font-size: 16px;
      font-weight: 600;
      color: #fbbf24;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    #new-game-btn {
      padding: 10px 20px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none; border-radius: 12px; color: white; font-weight: 600; font-size: 14px;
      cursor: pointer; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4); transition: transform 0.1s;
      touch-action: manipulation;
    }
    #new-game-btn:active { transform: scale(0.95); }

    #board {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      overscroll-behavior: contain;
      touch-action: none;
    }

    #top-row {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      height: 80px;
    }

    #tableau {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      min-height: 0;
    }

    .slot {
      background: rgba(0, 0, 0, 0.3);
      border: 2px dashed rgba(255, 255, 255, 0.4);
      border-radius: 12px;
      position: relative;
      backdrop-filter: blur(5px);
      transition: all 0.2s;
      overflow: hidden;
    }

    .slot.drag-over { background: rgba(16, 185, 129, 0.4); border-color: #10b981; box-shadow: 0 0 20px rgba(16, 185, 129, 0.6); }
    .empty-space { background: transparent; border: none; }
    .tableau-pile { position: relative; min-height: 100%; }

    .card {
      position: absolute;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, #ffffff 0%, #f3f4f6 100%);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 6px;
      border: 2px solid rgba(0, 0, 0, 0.1);
      top: 0; left: 0;
      touch-action: none;
    }

    .tableau-pile .card { width: 100%; height: auto; aspect-ratio: 2.5/3.5; position: absolute; }
    .card.dragging { opacity: 0.8; z-index: 10000 !important; position: fixed !important; pointer-events: none; }
    .card.ghost { opacity: 0.3; }
    .card.red { color: #ef4444; }
    .card.black { color: #1f2937; }

    .card.face-down {
      background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    .card.face-down::before {
      content: 'â™ '; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 32px; color: rgba(255, 255, 255, 0.3);
    }

    .card-top, .card-bottom { font-size: 14px; font-weight: 700; line-height: 1; }
    .card-bottom { text-align: right; transform: rotate(180deg); }
    .card-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; }

    #stock-slot {
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      font-size: 32px; color: rgba(255, 255, 255, 0.3);
      touch-action: manipulation;
    }
    #stock-slot.empty::before { content: 'â†»'; font-size: 40px; color: rgba(255, 255, 255, 0.6); animation: pulse 2s infinite; }
    @keyframes pulse { 0%,100%{opacity:.6;transform:scale(1)} 50%{opacity:.9;transform:scale(1.1)} }

    #win-screen {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(10px); z-index: 10000;
      align-items: center; justify-content: center; flex-direction: column; gap: 20px;
    }
    #win-screen.show { display: flex; }
    #win-message {
      font-size: 48px; font-weight: 700;
      background: linear-gradient(135deg, #fbbf24, #f59e0b, #fbbf24);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shimmer 2s infinite;
    }
    @keyframes shimmer { 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.3)} }
    #win-stats { font-size: 24px; color: #10b981; text-shadow: 0 2px 8px rgba(16,185,129,.5); }

    #drag-clone { position: fixed; pointer-events: none; z-index:10000; width: 50px; height: 70px; opacity: .9; }

    @media (max-width: 600px) {
      #top-row { height: 60px; }
      .card-top, .card-bottom { font-size: 11px; }
      .card-center { font-size: 20px; }
      .card { padding: 4px; }
      #drag-clone { width: 40px; height: 56px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="controls">
      <div id="score-display">Score: 0 | Moves: 0</div>
      <button id="new-game-btn">New Game</button>
    </div>

    <div id="board">
      <div id="top-row">
        <div id="stock-slot" class="slot"></div>
        <div id="waste-slot" class="slot"></div>
        <div class="empty-space"></div>
        <div id="foundation-0" class="slot foundation"></div>
        <div id="foundation-1" class="slot foundation"></div>
        <div id="foundation-2" class="slot foundation"></div>
        <div id="foundation-3" class="slot foundation"></div>
      </div>

      <div id="tableau">
        <div id="tableau-0" class="tableau-pile"></div>
        <div id="tableau-1" class="tableau-pile"></div>
        <div id="tableau-2" class="tableau-pile"></div>
        <div id="tableau-3" class="tableau-pile"></div>
        <div id="tableau-4" class="tableau-pile"></div>
        <div id="tableau-5" class="tableau-pile"></div>
        <div id="tableau-6" class="tableau-pile"></div>
      </div>
    </div>
  </div>

  <div id="win-screen">
    <div id="win-message">ðŸŽ‰ You Win! ðŸŽ‰</div>
    <div id="win-stats"></div>
    <button id="new-game-btn-win" style="padding:15px 40px;background:linear-gradient(135deg,#10b981 0%,#059669 100%);border:none;border-radius:12px;color:white;font-weight:600;font-size:18px;cursor:pointer;box-shadow:0 4px 12px rgba(16,185,129,.4);touch-action:manipulation">Play Again</button>
  </div>

  <script>
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('portrait').catch(() => {});
    }

    function requestFs() {
      const el = document.documentElement;
      const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
      if (req) req.call(el).catch(()=>{});
    }
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('new-game-btn').addEventListener('click', requestFs, { once: true });
      document.getElementById('board').addEventListener('pointerdown', requestFs, { once: true });
    });

    function setVh() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    setVh();
    window.addEventListener('resize', setVh);
    window.addEventListener('orientationchange', setVh);
    document.addEventListener('visibilitychange', setVh);
    window.addEventListener('pageshow', setVh);

    function blockIfMultiTouch(e) {
      if (e.touches && e.touches.length > 1) e.preventDefault();
    }
    document.addEventListener('touchstart', blockIfMultiTouch, { passive: false });
    document.addEventListener('touchmove', blockIfMultiTouch, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    document.addEventListener('wheel', function(e) {
      if (e.ctrlKey) e.preventDefault();
    }, { passive: false });

    ['gesturestart','gesturechange','gestureend'].forEach(type => {
      document.addEventListener(type, e => e.preventDefault(), { passive: false });
    });

    const suits = ['â™ ','â™¥','â™¦','â™£'];
    const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    let deck = [], stock = [], waste = [], foundations = [[],[],[],[]], tableau = [[],[],[],[],[],[],[]];
    let score = 0, moves = 0, draggedCards = [], draggedFrom = null, isDragging = false, dragClone = null, startX = 0, startY = 0;

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(frequency, duration, type = 'sine') {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
      oscillator.frequency.value = frequency; oscillator.type = type;
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + duration);
    }

    function haptic(style = 'medium') {
      if (navigator.vibrate) {
        const patterns = { light: 10, medium: 20, heavy: 30, success: [10,50,10], error: [20,100,20] };
        navigator.vibrate(patterns[style] || 20);
      }
    }

    function createDeck() {
      deck = [];
      for (let suit of suits) for (let rank of ranks) {
        deck.push({ suit, rank, color: (suit==='â™¥'||suit==='â™¦')?'red':'black', value: ranks.indexOf(rank)+1, faceUp: false });
      }
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    function dealCards() {
      stock = [...deck]; waste = []; foundations = [[],[],[],[]]; tableau = [[],[],[],[],[],[],[]];
      for (let i = 0; i < 7; i++) {
        for (let j = i; j < 7; j++) {
          const card = stock.pop(); card.faceUp = (i === j); tableau[j].push(card);
        }
      }
    }

    function newGame() {
      createDeck(); dealCards(); score = 0; moves = 0; updateDisplay();
      playSound(400, 0.1); haptic('medium'); document.getElementById('win-screen').classList.remove('show');
    }

    function updateDisplay() {
      document.getElementById('score-display').textContent = `Score: ${score} | Moves: ${moves}`;
      const stockSlot = document.getElementById('stock-slot');
      stockSlot.innerHTML = '';
      if (stock.length > 0) {
        stockSlot.classList.remove('empty');
        const cardEl = createCardElement(stock[stock.length - 1], false);
        stockSlot.appendChild(cardEl);
      } else {
        stockSlot.classList.add('empty');
      }

      const wasteSlot = document.getElementById('waste-slot');
      wasteSlot.innerHTML = '';
      if (waste.length > 0) {
        const cardEl = createCardElement(waste[waste.length - 1], true);
        cardEl.dataset.location = 'waste';
        wasteSlot.appendChild(cardEl);
      }

      for (let i = 0; i < 4; i++) {
        const foundationSlot = document.getElementById(`foundation-${i}`);
        foundationSlot.innerHTML = '';
        if (foundations[i].length > 0) {
          const cardEl = createCardElement(foundations[i][foundations[i].length - 1], true);
          cardEl.dataset.location = 'foundation';
          cardEl.dataset.foundationIndex = i;
          foundationSlot.appendChild(cardEl);
        }
      }

      for (let i = 0; i < 7; i++) {
        const tableauPile = document.getElementById(`tableau-${i}`);
        tableauPile.innerHTML = '';
        tableau[i].forEach((card, index) => {
          const cardEl = createCardElement(card, card.faceUp);
          tableauPile.appendChild(cardEl);
          cardEl.style.top = `${index * 20}px`;
          cardEl.dataset.pileIndex = i;
          cardEl.dataset.cardIndex = index;
        });
      }

      checkWin();
    }

    function createCardElement(card, faceUp) {
      const cardEl = document.createElement('div');
      cardEl.className = `card ${card.color}`;
      if (!faceUp) { cardEl.classList.add('face-down'); return cardEl; }
      const topLabel = document.createElement('div'); topLabel.className = 'card-top'; topLabel.textContent = card.rank + card.suit;
      const centerLabel = document.createElement('div'); centerLabel.className = 'card-center'; centerLabel.textContent = card.suit;
      const bottomLabel = document.createElement('div'); bottomLabel.className = 'card-bottom'; bottomLabel.textContent = card.rank + card.suit;
      cardEl.appendChild(topLabel); cardEl.appendChild(centerLabel); cardEl.appendChild(bottomLabel);
      return cardEl;
    }

    function checkWin() {
      const allFoundationsFull = foundations.every(f => f.length === 13);
      if (allFoundationsFull) {
        document.getElementById('win-stats').textContent = `Score: ${score} | Moves: ${moves}`;
        document.getElementById('win-screen').classList.add('show');
        playSound(523, 0.2); setTimeout(() => playSound(659, 0.2), 150); setTimeout(() => playSound(784, 0.3), 300);
        haptic('success');
      }
    }

    document.getElementById('stock-slot').addEventListener('click', () => {
      if (stock.length > 0) {
        const card = stock.pop(); card.faceUp = true; waste.push(card); moves++; playSound(300, 0.05); haptic('light');
      } else if (waste.length > 0) {
        stock = waste.reverse(); waste = [];
        stock.forEach(card => card.faceUp = false);
        playSound(350, 0.1); haptic('medium');
      }
      updateDisplay();
    });

    document.getElementById('new-game-btn').addEventListener('click', newGame);
    document.getElementById('new-game-btn-win').addEventListener('click', newGame);

    let clickTimeout = null, clickCount = 0, lastClickTarget = null;
    document.getElementById('board').addEventListener('pointerdown', (e) => {
      const card = e.target.closest('.card'); if (!card || card.classList.contains('face-down')) return;
      startX = e.clientX; startY = e.clientY; isDragging = false;
      const location = card.dataset.location;

      if (location === 'waste') { draggedFrom = { type: 'waste' }; draggedCards = [waste[waste.length - 1]]; }
      else if (location === 'foundation') {
        const foundationIndex = parseInt(card.dataset.foundationIndex);
        draggedFrom = { type: 'foundation', index: foundationIndex };
        draggedCards = [foundations[foundationIndex][foundations[foundationIndex].length - 1]];
      } else {
        const pileIndex = parseInt(card.dataset.pileIndex);
        const cardIndex = parseInt(card.dataset.cardIndex);
        if (!isNaN(pileIndex) && !isNaN(cardIndex)) {
          draggedFrom = { type: 'tableau', index: pileIndex };
          draggedCards = tableau[pileIndex].slice(cardIndex);
        }
      }

      if (draggedCards.length > 0) {
        haptic('light');
        if (lastClickTarget === card) { clickCount++; } else { clickCount = 1; lastClickTarget = card; }
        if (clickCount === 2) {
          clearTimeout(clickTimeout); clickCount = 0; lastClickTarget = null; draggedCards = []; draggedFrom = null;
          if (location === 'waste') { autoMoveToFoundationFromWaste(); }
          else if (!isNaN(card.dataset.pileIndex) && !isNaN(card.dataset.cardIndex)) {
            autoMoveToFoundation(parseInt(card.dataset.pileIndex), parseInt(card.dataset.cardIndex));
          }
          return;
        }
        clickTimeout = setTimeout(() => { clickCount = 0; lastClickTarget = null; }, 300);
      }
    });

    document.addEventListener('pointermove', (e) => {
      if (draggedCards.length === 0) return;
      const distance = Math.hypot(e.clientX - startX, e.clientY - startY);
      if (!isDragging && distance > 10) {
        isDragging = true;
        dragClone = createCardElement(draggedCards[0], true);
        dragClone.id = 'drag-clone';
        document.body.appendChild(dragClone);
      }
      if (isDragging && dragClone) {
        dragClone.style.left = `${e.clientX - 25}px`;
        dragClone.style.top = `${e.clientY - 35}px`;
      }
    });

    document.addEventListener('pointerup', (e) => {
      if (isDragging && dragClone) {
        dragClone.remove(); dragClone = null;
        const dropTarget = document.elementFromPoint(e.clientX, e.clientY);
        handleDrop(dropTarget);
      }
      draggedCards = []; draggedFrom = null; isDragging = false;
    });

    function handleDrop(dropTarget) {
      if (!dropTarget) { updateDisplay(); return; }
      const foundationSlot = dropTarget.closest('.foundation');
      if (foundationSlot && draggedCards.length === 1) {
        const foundationIndex = parseInt(foundationSlot.id.split('-')[1]);
        if (canMoveToFoundation(draggedCards[0], foundationIndex)) { moveToFoundation(foundationIndex); return; }
      }
      const tableauPile = dropTarget.closest('.tableau-pile');
      if (tableauPile) {
        const pileIndex = parseInt(tableauPile.id.split('-')[1]);
        if (canMoveToTableau(draggedCards[0], pileIndex)) { moveToTableau(pileIndex); return; }
      }
      updateDisplay();
    }

    function canMoveToFoundation(card, foundationIndex) {
      const foundation = foundations[foundationIndex];
      if (foundation.length === 0) return card.rank === 'A';
      const topCard = foundation[foundation.length - 1];
      return card.suit === topCard.suit && card.value === topCard.value + 1;
    }

    function canMoveToTableau(card, pileIndex) {
      const pile = tableau[pileIndex];
      if (pile.length === 0) return card.rank === 'K';
      const topCard = pile[pile.length - 1];
      return card.color !== topCard.color && card.value === topCard.value - 1;
    }

    function moveToFoundation(foundationIndex) {
      if (draggedFrom.type === 'waste') {
        foundations[foundationIndex].push(waste.pop());
      } else if (draggedFrom.type === 'tableau') {
        const pile = tableau[draggedFrom.index];
        foundations[foundationIndex].push(pile.pop());
        if (pile.length > 0) pile[pile.length - 1].faceUp = true;
      } else if (draggedFrom.type === 'foundation') {
        const fromFoundation = foundations[draggedFrom.index];
        foundations[foundationIndex].push(fromFoundation.pop());
      }
      score += 10; moves++; playSound(500, 0.1); haptic('medium'); updateDisplay();
    }

    function moveToTableau(pileIndex) {
      if (draggedFrom.type === 'waste') {
        tableau[pileIndex].push(waste.pop());
      } else if (draggedFrom.type === 'tableau') {
        const fromPile = tableau[draggedFrom.index];
        const movingCards = fromPile.splice(fromPile.length - draggedCards.length);
        tableau[pileIndex].push(...movingCards);
        if (fromPile.length > 0) fromPile[fromPile.length - 1].faceUp = true;
      } else if (draggedFrom.type === 'foundation') {
        tableau[pileIndex].push(foundations[draggedFrom.index].pop());
      }
      score += 5; moves++; playSound(450, 0.1); haptic('medium'); updateDisplay();
    }

    function autoMoveToFoundation(pileIndex, cardIndex) {
      if (cardIndex !== tableau[pileIndex].length - 1) return;
      const card = tableau[pileIndex][cardIndex];
      for (let i = 0; i < 4; i++) {
        if (canMoveToFoundation(card, i)) {
          draggedFrom = { type: 'tableau', index: pileIndex }; draggedCards = [card]; moveToFoundation(i); return;
        }
      }
    }

    function autoMoveToFoundationFromWaste() {
      if (waste.length === 0) return;
      const card = waste[waste.length - 1];
      for (let i = 0; i < 4; i++) {
        if (canMoveToFoundation(card, i)) {
          draggedFrom = { type: 'waste' }; draggedCards = [card]; moveToFoundation(i); return;
        }
      }
    }

    newGame();
  </script>
</body>
</html>