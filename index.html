<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solitaire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'MS Sans Serif', Arial, sans-serif;
            background: #008080;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #header {
            background: linear-gradient(180deg, #000080 0%, #1084d0 100%);
            color: white;
            padding: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #c0c0c0;
            box-shadow: inset -1px -1px 0 #000000, inset 1px 1px 0 #dfdfdf;
        }

        #title {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #score-display {
            display: flex;
            gap: 15px;
            font-size: 14px;
        }

        #controls {
            padding: 8px;
            background: #c0c0c0;
            border-bottom: 2px solid #808080;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            background: #c0c0c0;
            border: 2px solid;
            border-color: #ffffff #000000 #000000 #ffffff;
            padding: 6px 12px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 13px;
            cursor: pointer;
            box-shadow: inset 1px 1px 0 #dfdfdf, inset -1px -1px 0 #808080;
            touch-action: manipulation;
        }

        .btn:active {
            border-color: #000000 #ffffff #ffffff #000000;
            box-shadow: inset -1px -1px 0 #dfdfdf, inset 1px 1px 0 #808080;
            padding: 7px 11px 5px 13px;
        }

        #game-board {
            flex: 1;
            padding: 15px;
            overflow: auto;
            position: relative;
        }

        #board-content {
            min-height: 600px;
            position: relative;
        }

        .card-slot {
            position: absolute;
            width: 70px;
            height: 95px;
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 5px;
            background: rgba(0,0,0,0.1);
        }

        .card {
            position: absolute;
            width: 70px;
            height: 95px;
            background: white;
            border: 2px solid #000;
            border-radius: 5px;
            cursor: pointer;
            user-select: none;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            transition: none;
            touch-action: none;
        }

        .card.dragging {
            opacity: 0.8;
            z-index: 1000 !important;
        }

        .card.back {
            background: linear-gradient(135deg, #0000aa 0%, #0000ff 50%, #0000aa 100%);
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,.1) 10px, rgba(255,255,255,.1) 20px),
                repeating-linear-gradient(-45deg, transparent, transparent 10px, rgba(255,255,255,.1) 10px, rgba(255,255,255,.1) 20px);
        }

        .card-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 4px;
            position: relative;
            pointer-events: none;
        }

        .card-rank {
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
        }

        .card-suit {
            font-size: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .card-rank-bottom {
            font-size: 16px;
            font-weight: bold;
            position: absolute;
            bottom: 4px;
            right: 4px;
            transform: rotate(180deg);
        }

        .red {
            color: #ff0000;
        }

        .black {
            color: #000000;
        }

        #win-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #win-message {
            background: #c0c0c0;
            border: 3px solid;
            border-color: #ffffff #000000 #000000 #ffffff;
            padding: 30px;
            text-align: center;
            box-shadow: inset 1px 1px 0 #dfdfdf, inset -1px -1px 0 #808080;
        }

        #win-message h2 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #000080;
        }

        #win-message p {
            font-size: 16px;
            margin-bottom: 20px;
        }

        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
        }

        @media (max-width: 768px) {
            .card, .card-slot {
                width: 60px;
                height: 82px;
            }
            
            .card-rank, .card-rank-bottom {
                font-size: 14px;
            }
            
            .card-suit {
                font-size: 18px;
            }

            #board-content {
                min-height: 500px;
            }
        }

        @media (max-width: 480px) {
            .card, .card-slot {
                width: 50px;
                height: 68px;
            }
            
            .card-rank, .card-rank-bottom {
                font-size: 12px;
            }
            
            .card-suit {
                font-size: 16px;
            }

            #header {
                padding: 6px;
            }

            #title {
                font-size: 14px;
            }

            #score-display {
                font-size: 12px;
                gap: 10px;
            }

            .btn {
                padding: 5px 10px;
                font-size: 12px;
            }
        }

        @media (orientation: portrait) {
            body {
                transform: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="header">
            <div id="title">â™  Solitaire â™¥</div>
            <div id="score-display">
                <span>Score: <span id="score">0</span></span>
                <span>Moves: <span id="moves">0</span></span>
            </div>
        </div>
        
        <div id="controls">
            <button class="btn" onclick="newGame()">New Game</button>
            <button class="btn" onclick="undoMove()">Undo</button>
            <button class="btn" onclick="hint()">Hint</button>
        </div>

        <div id="game-board">
            <div id="board-content"></div>
        </div>
    </div>

    <div id="win-screen">
        <div id="win-message">
            <h2>ðŸŽ‰ You Win! ðŸŽ‰</h2>
            <p>Score: <span id="final-score"></span></p>
            <p>Moves: <span id="final-moves"></span></p>
            <button class="btn" onclick="newGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Audio Context for sounds
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'card':
                    oscillator.frequency.value = 300;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'place':
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'win':
                    [523, 587, 659, 698, 784].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.1 + 0.3);
                        osc.start(audioContext.currentTime + i * 0.1);
                        osc.stop(audioContext.currentTime + i * 0.1 + 0.3);
                    });
                    break;
                case 'error':
                    oscillator.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }

        function haptic(type = 'light') {
            if (navigator.vibrate) {
                switch(type) {
                    case 'light': navigator.vibrate(10); break;
                    case 'medium': navigator.vibrate(20); break;
                    case 'heavy': navigator.vibrate(50); break;
                    case 'success': navigator.vibrate([10, 50, 10]); break;
                }
            }
        }

        // Game state
        let deck = [];
        let stock = [];
        let waste = [];
        let foundations = [[], [], [], []];
        let tableau = [[], [], [], [], [], [], []];
        let score = 0;
        let moves = 0;
        let history = [];
        let draggedCards = [];
        let draggedFrom = null;
        let dragOffset = { x: 0, y: 0 };
        let dragGhosts = [];
        let lastClickTime = 0;
        let lastClickTarget = null;
        let isDragging = false;

        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const rankValues = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };

        function createDeck() {
            deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({
                        suit: suit,
                        rank: rank,
                        color: (suit === 'â™¥' || suit === 'â™¦') ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            // Shuffle
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function newGame() {
            createDeck();
            stock = [];
            waste = [];
            foundations = [[], [], [], []];
            tableau = [[], [], [], [], [], [], []];
            score = 0;
            moves = 0;
            history = [];
            
            // Deal to tableau
            for (let i = 0; i < 7; i++) {
                for (let j = i; j < 7; j++) {
                    const card = deck.pop();
                    if (i === j) card.faceUp = true;
                    tableau[j].push(card);
                }
            }
            
            // Rest to stock
            stock = deck;
            
            updateDisplay();
            document.getElementById('win-screen').style.display = 'none';
            haptic('medium');
        }

        function updateDisplay() {
            const board = document.getElementById('board-content');
            board.innerHTML = '';
            
            const cardWidth = window.innerWidth < 480 ? 50 : (window.innerWidth < 768 ? 60 : 70);
            const cardHeight = window.innerWidth < 480 ? 68 : (window.innerWidth < 768 ? 82 : 95);
            const gap = 10;
            const stackOffset = window.innerWidth < 480 ? 15 : 20;
            
            // Stock pile
            const stockSlot = createSlot(gap, gap);
            board.appendChild(stockSlot);
            
            if (stock.length > 0) {
                const stockCard = createCardElement(stock[stock.length - 1], false);
                stockCard.style.left = gap + 'px';
                stockCard.style.top = gap + 'px';
                stockCard.style.zIndex = 100;
                stockCard.onclick = () => {
                    drawCard();
                    haptic('light');
                };
                board.appendChild(stockCard);
            }
            
            // Waste pile
            const wasteSlot = createSlot(gap + cardWidth + gap, gap);
            board.appendChild(wasteSlot);
            
            if (waste.length > 0) {
                const wasteCard = createCardElement(waste[waste.length - 1], true);
                wasteCard.style.left = (gap + cardWidth + gap) + 'px';
                wasteCard.style.top = gap + 'px';
                wasteCard.style.zIndex = 100;
                wasteCard.dataset.from = 'waste';
                wasteCard.dataset.index = waste.length - 1;
                addDragListeners(wasteCard);
                addDoubleClickListener(wasteCard, 'waste', 0, waste.length - 1);
                board.appendChild(wasteCard);
            }
            
            // Foundations
            for (let i = 0; i < 4; i++) {
                const x = gap + (cardWidth + gap) * (3 + i);
                const foundSlot = createSlot(x, gap);
                foundSlot.dataset.foundation = i;
                foundSlot.classList.add('foundation-slot');
                board.appendChild(foundSlot);
                
                if (foundations[i].length > 0) {
                    const foundCard = createCardElement(foundations[i][foundations[i].length - 1], true);
                    foundCard.style.left = x + 'px';
                    foundCard.style.top = gap + 'px';
                    foundCard.style.zIndex = 100;
                    foundCard.dataset.from = 'foundation';
                    foundCard.dataset.pile = i;
                    foundCard.dataset.index = foundations[i].length - 1;
                    addDragListeners(foundCard);
                    addDoubleClickListener(foundCard, 'foundation', i, foundations[i].length - 1);
                    board.appendChild(foundCard);
                }
            }
            
            // Tableau
            for (let i = 0; i < 7; i++) {
                const x = gap + (cardWidth + gap) * i;
                const y = gap + cardHeight + gap + 20;
                
                const tabSlot = createSlot(x, y);
                tabSlot.dataset.tableau = i;
                tabSlot.classList.add('tableau-slot');
                board.appendChild(tabSlot);
                
                tableau[i].forEach((card, idx) => {
                    const cardEl = createCardElement(card, card.faceUp);
                    cardEl.style.left = x + 'px';
                    cardEl.style.top = (y + idx * stackOffset) + 'px';
                    cardEl.style.zIndex = 200 + idx;
                    
                    if (card.faceUp) {
                        cardEl.dataset.from = 'tableau';
                        cardEl.dataset.pile = i;
                        cardEl.dataset.index = idx;
                        addDragListeners(cardEl);
                        addDoubleClickListener(cardEl, 'tableau', i, idx);
                    } else {
                        cardEl.onclick = () => {
                            if (idx === tableau[i].length - 1) {
                                card.faceUp = true;
                                updateDisplay();
                                playSound('card');
                                haptic('light');
                            }
                        };
                    }
                    
                    board.appendChild(cardEl);
                });
            }
            
            document.getElementById('score').textContent = score;
            document.getElementById('moves').textContent = moves;
        }

        function createSlot(x, y) {
            const slot = document.createElement('div');
            slot.className = 'card-slot';
            slot.style.left = x + 'px';
            slot.style.top = y + 'px';
            return slot;
        }

        function createCardElement(card, faceUp) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card' + (faceUp ? '' : ' back');
            
            if (faceUp) {
                const content = document.createElement('div');
                content.className = 'card-content';
                
                const rankTop = document.createElement('div');
                rankTop.className = 'card-rank ' + card.color;
                rankTop.textContent = card.rank;
                
                const suit = document.createElement('div');
                suit.className = 'card-suit ' + card.color;
                suit.textContent = card.suit;
                
                const rankBottom = document.createElement('div');
                rankBottom.className = 'card-rank-bottom ' + card.color;
                rankBottom.textContent = card.rank;
                
                content.appendChild(rankTop);
                content.appendChild(suit);
                content.appendChild(rankBottom);
                cardEl.appendChild(content);
            }
            
            return cardEl;
        }

        function addDoubleClickListener(cardEl, fromType, pileIndex, cardIndex) {
            cardEl.addEventListener('click', (e) => {
                if (isDragging) return;
                
                const currentTime = Date.now();
                const timeDiff = currentTime - lastClickTime;
                
                if (timeDiff < 400 && lastClickTarget === cardEl) {
                    // Double click detected
                    e.preventDefault();
                    e.stopPropagation();
                    tryAutoMoveToFoundation(fromType, pileIndex, cardIndex);
                    lastClickTime = 0;
                    lastClickTarget = null;
                } else {
                    lastClickTime = currentTime;
                    lastClickTarget = cardEl;
                }
            });
        }

        function addDragListeners(cardEl) {
            cardEl.addEventListener('mousedown', startDrag);
            cardEl.addEventListener('touchstart', startDrag, { passive: false });
        }

        function startDrag(e) {
            e.preventDefault();
            e.stopPropagation();
            
            isDragging = false;
            
            const cardEl = e.currentTarget;
            const rect = cardEl.getBoundingClientRect();
            
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            
            // Calculate offset from card's top-left corner
            dragOffset.x = clientX - rect.left;
            dragOffset.y = clientY - rect.top;
            
            draggedFrom = {
                type: cardEl.dataset.from,
                pile: parseInt(cardEl.dataset.pile),
                index: parseInt(cardEl.dataset.index)
            };
            
            // Collect all cards to drag (for tableau stacks)
            draggedCards = [];
            const stackOffset = window.innerWidth < 480 ? 15 : 20;
            
            if (draggedFrom.type === 'tableau') {
                const pile = tableau[draggedFrom.pile];
                for (let i = draggedFrom.index; i < pile.length; i++) {
                    draggedCards.push({
                        card: pile[i],
                        offsetY: (i - draggedFrom.index) * stackOffset
                    });
                }
            } else if (draggedFrom.type === 'waste') {
                draggedCards.push({
                    card: waste[waste.length - 1],
                    offsetY: 0
                });
            } else if (draggedFrom.type === 'foundation') {
                draggedCards.push({
                    card: foundations[draggedFrom.pile][draggedFrom.index],
                    offsetY: 0
                });
            }
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function drag(e) {
            if (!isDragging && draggedCards.length > 0) {
                isDragging = true;
                
                // Create ghost cards for dragging
                dragGhosts = [];
                draggedCards.forEach((cardData, idx) => {
                    const ghost = createCardElement(cardData.card, true);
                    ghost.className = 'card drag-ghost';
                    document.body.appendChild(ghost);
                    dragGhosts.push(ghost);
                });
                
                // Hide original cards
                const allCards = document.querySelectorAll('.card');
                allCards.forEach(card => {
                    if (card.dataset.from === draggedFrom.type) {
                        if (draggedFrom.type === 'waste' || draggedFrom.type === 'foundation' ||
                            (card.dataset.pile == draggedFrom.pile && card.dataset.index >= draggedFrom.index)) {
                            card.style.opacity = '0.3';
                        }
                    }
                });
                
                playSound('card');
                haptic('light');
            }
            
            if (dragGhosts.length === 0) return;
            e.preventDefault();
            
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            
            // Move all ghost cards
            dragGhosts.forEach((ghost, idx) => {
                ghost.style.left = (clientX - dragOffset.x) + 'px';
                ghost.style.top = (clientY - dragOffset.y + draggedCards[idx].offsetY) + 'px';
            });
        }

        function endDrag(e) {
            if (dragGhosts.length === 0) {
                isDragging = false;
                draggedCards = [];
                draggedFrom = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('touchend', endDrag);
                return;
            }
            
            const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
            
            // Find what's under the drop point
            const elements = document.elementsFromPoint(clientX, clientY);
            let placed = false;
            
            for (let element of elements) {
                if (element.dataset.foundation !== undefined) {
                    if (draggedCards.length === 1) {
                        placed = tryPlaceOnFoundation(parseInt(element.dataset.foundation));
                    }
                    break;
                } else if (element.dataset.tableau !== undefined) {
                    placed = tryPlaceOnTableau(parseInt(element.dataset.tableau));
                    break;
                } else if (element.classList.contains('card')) {
                    // Check if dropped on a card
                    if (element.dataset.from === 'tableau') {
                        placed = tryPlaceOnTableau(parseInt(element.dataset.pile));
                        break;
                    }
                }
            }
            
            if (!placed) {
                playSound('error');
                haptic('light');
            }
            
            // Clean up ghosts
            dragGhosts.forEach(ghost => ghost.remove());
            dragGhosts = [];
            draggedCards = [];
            draggedFrom = null;
            isDragging = false;
            
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', endDrag);
            
            updateDisplay();
        }

        function drawCard() {
            if (stock.length > 0) {
                const card = stock.pop();
                card.faceUp = true;
                waste.push(card);
                moves++;
                playSound('card');
            } else if (waste.length > 0) {
                stock = waste.reverse();
                stock.forEach(c => c.faceUp = false);
                waste = [];
                playSound('card');
            }
            updateDisplay();
        }

        function tryPlaceOnFoundation(foundIndex) {
            if (!draggedFrom || draggedCards.length !== 1) return false;
            
            const card = draggedCards[0].card;
            const foundation = foundations[foundIndex];
            
            if (foundation.length === 0) {
                if (card.rank === 'A') {
                    moveCardToFoundation(foundIndex);
                    return true;
                }
            } else {
                const topCard = foundation[foundation.length - 1];
                if (card.suit === topCard.suit && rankValues[card.rank] === rankValues[topCard.rank] + 1) {
                    moveCardToFoundation(foundIndex);
                    return true;
                }
            }
            
            return false;
        }

        function moveCardToFoundation(foundIndex) {
            const card = draggedCards[0].card;
            
            if (draggedFrom.type === 'waste') {
                waste.pop();
            } else if (draggedFrom.type === 'tableau') {
                tableau[draggedFrom.pile].pop();
                if (tableau[draggedFrom.pile].length > 0) {
                    tableau[draggedFrom.pile][tableau[draggedFrom.pile].length - 1].faceUp = true;
                }
            } else if (draggedFrom.type === 'foundation') {
                foundations[draggedFrom.pile].pop();
            }
            
            foundations[foundIndex].push(card);
            score += 10;
            moves++;
            playSound('place');
            haptic('medium');
            
            checkWin();
        }

        function tryPlaceOnTableau(tabIndex) {
            if (!draggedFrom || draggedCards.length === 0) return false;
            
            const card = draggedCards[0].card;
            const targetPile = tableau[tabIndex];
            
            if (targetPile.length === 0) {
                if (card.rank === 'K') {
                    moveCardToTableau(tabIndex);
                    return true;
                }
            } else {
                const topCard = targetPile[targetPile.length - 1];
                if (card.color !== topCard.color && rankValues[card.rank] === rankValues[topCard.rank] - 1) {
                    moveCardToTableau(tabIndex);
                    return true;
                }
            }
            
            return false;
        }

        function moveCardToTableau(tabIndex) {
            if (draggedFrom.type === 'waste') {
                const card = waste.pop();
                tableau[tabIndex].push(card);
            } else if (draggedFrom.type === 'tableau') {
                const cards = tableau[draggedFrom.pile].splice(draggedFrom.index);
                tableau[tabIndex].push(...cards);
                if (tableau[draggedFrom.pile].length > 0) {
                    tableau[draggedFrom.pile][tableau[draggedFrom.pile].length - 1].faceUp = true;
                }
            } else if (draggedFrom.type === 'foundation') {
                const card = foundations[draggedFrom.pile].pop();
                tableau[tabIndex].push(card);
            }
            
            moves++;
            playSound('place');
            haptic('medium');
        }

        function tryAutoMoveToFoundation(fromType, pileIndex, cardIndex) {
            let card;
            
            if (fromType === 'tableau') {
                if (cardIndex !== tableau[pileIndex].length - 1) return;
                card = tableau[pileIndex][cardIndex];
            } else if (fromType === 'waste') {
                card = waste[waste.length - 1];
            } else if (fromType === 'foundation') {
                // Can't auto-move from foundation to foundation
                return;
            } else {
                return;
            }
            
            for (let i = 0; i < 4; i++) {
                const foundation = foundations[i];
                if (foundation.length === 0 && card.rank === 'A') {
                    if (fromType === 'tableau') {
                        tableau[pileIndex].pop();
                        if (tableau[pileIndex].length > 0) {
                            tableau[pileIndex][tableau[pileIndex].length - 1].faceUp = true;
                        }
                    } else if (fromType === 'waste') {
                        waste.pop();
                    }
                    foundations[i].push(card);
                    score += 10;
                    moves++;
                    playSound('place');
                    haptic('medium');
                    updateDisplay();
                    checkWin();
                    return;
                } else if (foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    if (card.suit === topCard.suit && rankValues[card.rank] === rankValues[topCard.rank] + 1) {
                        if (fromType === 'tableau') {
                            tableau[pileIndex].pop();
                            if (tableau[pileIndex].length > 0) {
                                tableau[pileIndex][tableau[pileIndex].length - 1].faceUp = true;
                            }
                        } else if (fromType === 'waste') {
                            waste.pop();
                        }
                        foundations[i].push(card);
                        score += 10;
                        moves++;
                        playSound('place');
                        haptic('medium');
                        updateDisplay();
                        checkWin();
                        return;
                    }
                }
            }
        }

        function checkWin() {
            const totalCards = foundations.reduce((sum, pile) => sum + pile.length, 0);
            if (totalCards === 52) {
                setTimeout(() => {
                    document.getElementById('final-score').textContent = score;
                    document.getElementById('final-moves').textContent = moves;
                    document.getElementById('win-screen').style.display = 'flex';
                    playSound('win');
                    haptic('success');
                }, 300);
            }
        }

        function undoMove() {
            haptic('light');
            playSound('card');
        }

        function hint() {
            haptic('light');
            playSound('card');
        }

        // Initialize
        newGame();
    </script>
</body>
</html>
